{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"The ECE398 Weather Station","text":"<p>The ECE 398 Weather Station was designed and realized by students enrolled in Vertically Integrated Projects in the Electrical Engineering department at Bradley University. This project aims to provide students on Bradley's campus a way to monitor and log weather data. In the future, we hope this project expands to hosting multiple weather nodes that can all work together to accurately predict weather on campus.</p> <p>This site serves to document the Weather Station software and provides instruction for running the software on other systems efficiently.</p>"},{"location":"#accessing-our-data","title":"Accessing Our Data","text":"<p>In its current form, the Weather Station is just one node that uploads data to a server which is accessible at weather.jacobsimeone.net.</p> <p>This website gets its data from a publicly-accessible API, which users are also free to use at weather.jacobsimeone.net/api/envdata</p>"},{"location":"#design-overview","title":"Design Overview","text":"<p>The hardware used in the weather station is either off-the-shelf or 3d-printed in-house on Prusa Mk4S printers. Our CAD can be found on OnShape.</p> <p>Furthermore, the ECE 398 Weather Station project is split up into four primary pieces of software:</p> <ul> <li>The Firmware, which runs on the microcontroller that collects the data</li> <li>A Broker, which \"translates\" LoRa messages into network traffic that can be posted to the API</li> <li>An API, used for saving data to a database and accessing said data later</li> <li>The Website, an example of implementation for what one can do with the data and is how we currently share our data.</li> </ul> <pre><code>graph TD\n    subgraph Weather Station\n        sen[Sensors]\n        ws[Weather Station Controller]\n        lr[LoRa Radio]\n        sen --&gt;|SPI| ws\n        ws --&gt;|UART| lr\n    end\n    lr --&gt;|LoRa| blr[Broker Radio]\n    subgraph On-Site Server\n        blr --&gt;|UART| b[Broker]\n    end\n    b --&gt;|Over Internet, JSON| api([API, node.js])\n    subgraph Cloud Server\n        api --&gt; db[(Database, redis)]\n        db --&gt; api\n        api --&gt;|JSON| web[Website, Next.js]\n    end\n    c[Client] --&gt; web\n    web --&gt; c</code></pre> <p>The Weather Station, equipped with a LoRa radio, transmits data to a broker equipped with the same radio where the data is parsed and converted into JSON to publish to the API. The API then saves that data to a Redis database located on the same physical server which can also be hosting the website. (The website can be hosted remotely, but you will need to set the API endpoint) Clients can then connect to the website to view data served by the API.</p> <p>Broker Radio Location</p> <p>However the radio is connected to the on-site server is fine, but the radio on the Weather Station and the radio on the broker must be in range of each other.</p>"},{"location":"#tech-stack","title":"Tech Stack","text":"<p>Maintainers of the Weather Station should be proficient in the following technologies to effectively support the Weather Station system:</p>"},{"location":"#firmware","title":"Firmware","text":"<ul> <li>PlatformIO - an IDE that works with VsCode and the Arduino framework</li> <li>ESP32 - Microcontroller used in the Weather Station (can be swapped in the future)</li> <li>LoRa - Long-Range radio communication technology used to transfer data</li> </ul>"},{"location":"#api","title":"API","text":"<ul> <li>node.js with typescript</li> <li>redis database - For storing weather data</li> <li>Nginx - Web server</li> </ul>"},{"location":"#website","title":"Website","text":"<ul> <li>Next.js web framework</li> </ul>"},{"location":"#user-manual","title":"User Manual","text":""},{"location":"#blink-codes","title":"Blink Codes","text":"<p>When powering on the station, the status LED will tell the user what is going on:</p> Blink Code Reason Off OK/Idle On Booting / Boot Retry Slow Blink Boot Failed Very fast blink Transmit"},{"location":"#inside-the-station","title":"Inside the Station","text":"<p>This shows the parts inside of the station that are commonly used by maintainers</p> <p></p>"},{"location":"api-access/","title":"Overview","text":"<p>The Bradley Weather Station web API allows access to weather data collected from the Weather Station. The API is written in Typescript and ran using the Node.js javascript runtime and express.js library. </p> <p>Logically, the API also acts as the orchestrator between the database, and consumers of the contained data. The API must be installed on the same server as the redis database. The API runs on port <code>27500</code>. (The port can be changed by altering source code)</p> <pre><code>---\ntitle: Logical Block Diagram\n---\ngraph LR\n    c[Client]\n    r[Redis Db]\n    a[API]\n\n    subgraph \"Web Server\"\n    r --&gt; a\n    a --&gt; r\n    end\n    c --&gt;|HTTP GET| a</code></pre> <pre><code>---\ntitle: Client Requesting Data\n---\nsequenceDiagram\n    Client-&gt;&gt;API: HTTP GET Request: /api/envdata\n    API-&gt;&gt;Redis: Request to read data from database\n    Redis-&gt;&gt;API: Return weather data to API\n    API-&gt;&gt;Client: Return JSON weather data to client</code></pre>"},{"location":"api-access/#requesting-data","title":"Requesting Data","text":"<p>Data is requested from the API over a HTTP(S) GET request. The API returns data in the JSON format. Supported endpoints are:</p> Endpoint Supported Methods /api/envdata GET"},{"location":"api-access/#get-apienvdata","title":"GET /api/envdata","text":"<p>Data is returned in JSON.</p> <p>Example: <pre><code>{\n    \"weatherData\": [\n    {\n      \"timestamp_unix_ms\": \"1745009674533\",\n      \"temp_c\": \"24.94\",\n      \"humid_prcnt\": \"27.75\",\n      \"pressure_kpa\": \"98.62\",\n      \"gas_kohms\": \"291.16\",\n      \"rain_an\": \"0\",\n      \"light_an\": \"3899\"\n    },\n\n    // ...\n\n    ]\n}\n</code></pre></p> <p>The root object: The <code>weatherData</code> array, contains the following members:</p> Key Description timestamp_unix_ms <code>unix-timestamp-ms</code>-<code>sample-num</code>, Timestamp when sample was taken temp_c Ambient air temperature, in degrees celsius humid_prcnt Relative humidity, 0-100% pressure_kpa Pressure, in kilo-Pascals gas_kohms Kilo-ohms measured resistance on internal BME680 gas sensor rain_an Analog rain sensor output: no real units. Digital output of ADC light_an Analog value of photoresistor divider: no real units. Digital output of ADC"},{"location":"api-access/#posting-data","title":"Posting Data","text":"<p>Posting data is a privileged operation that is manually added by administrators. Keys submitted by users are checked against a file in the api directory: <code>api.keys</code>, which contains hashes of user api keys manually added by admins. </p> <p>Users sending data to the <code>/api/envdata</code> endpoint over HTTP(S) POST request must define the \"Authorization\" HTTP header and populate the value with a pre-determined key, provisioned by administrators. The data is posted in the following format:</p> <pre><code>{\n    \"timestamp_unix_ms\": \"1745009674533\",\n    \"temp_c\": \"24.94\",\n    \"humid_prcnt\": \"27.75\",\n    \"pressure_kpa\": \"98.62\",\n    \"gas_kohms\": \"291.16\",\n    \"rain_an\": \"0\",\n    \"light_an\": \"3899\"\n}\n</code></pre> <p>Note that the <code>light_level</code> and <code>is_raining</code> values are the same here as in the GET request description.</p> <p>Security</p> <p>It is the responsibility of admins to follow security guidelines listed in this documentation, and other sources, to protect privileged operations like posting data. </p>"},{"location":"building/building/","title":"Building","text":"<p>This page has not yet been implemented. If you would like, contact jsimeone@mail.bradley.edu for more details.</p>"},{"location":"building/circuit-diagrams/","title":"Wiring Diagrams","text":""},{"location":"building/circuit-diagrams/#user-wiring","title":"User Wiring","text":"<p>The following diagram shows what parts wire to where on the control board. The control board has labels for each connection on the corresponding module. </p> <p></p>"},{"location":"building/circuit-diagrams/#control-board-schematic","title":"Control Board Schematic","text":"<p>Below is the schematic for the control board, showing where all the connections go internally on the PCB.</p> <p></p>"},{"location":"building/circuit-diagrams/#notes","title":"Notes","text":"<ul> <li>The photoresistor is at roughly 2k Ohms in a well-lit room</li> </ul>"},{"location":"building/requirements/","title":"Requirements","text":""},{"location":"building/requirements/#parts-list","title":"Parts List","text":"Part Quantity Price MPN Weather Station ESP32-Devkit-M1 1 $8.00 1965-ESP32-DEVKITM-1-ND BME280 1 $14.95 1528-1359-ND LoRa RYLR890 2 $16.00 5487-RYLR896-ND Red 5mmm LED 1 $0.29 754-1264-ND Photoresistor 1 $0.70 PDV-P8103-ND Aviation Connectors 1 $19.99 B0CLHYC221 Screw Terminals 1 $8.99 B088LVP6ML Proto Board Kit 1 $9.99 B072Z7Y19F Water Level Sensor 1 $1.95 1528-4965-ND WQ-44 Enclosure 1 $28.30 WQ-44-03 PK-064A Pole Mount Kit 1 $29.74 PK-064A UA-020 Hooked Vent 1 $5.37 UA-020 WP-44P-01 Panel For Enclosure 1 $3.12 WQ-44P-01 Solar Panel Mounting Bracket 1 $39.95 B088KB2LBL Solar Panel 1 $28.99 B00OZC3X1C RTD 1 $19.99 B075QC399C 6ah Lithium Ion Battery Pack 1 $48.44 - Sunny Buddy Battery Charger 1 $32.95 - Broker Raspberry Pi3b+ 1 $48.91 B07P4LSDYV Misc Parts Metric Hardware 1 $21.97 BOBYZ1KK1V PVC Cement 1 ~$13.00 - TOTAL: $401.59"},{"location":"building/requirements/#custom-pcbs","title":"Custom PCBs","text":""},{"location":"building/requirements/#rtd-converter-board","title":"RTD Converter Board","text":"<p>You will need the RTD converter board to build the station</p>"},{"location":"building/requirements/#control-board","title":"Control Board","text":"<p>The control board carries all of the control electronics and some sensors, including the RTD board. </p> <p>Both of these can be found in the GitHub repository (just click in the top-right of this page, in the header)</p>"},{"location":"building/requirements/#3d-printed-parts","title":"3D Printed Parts","text":"<p>The ECE 398 Weather Station also has a few printed parts to go along with the off the shelf mechanical design. Below are the links to the OnShape documents of these parts.</p> Part Quantity Battery Holder 2 Rain Sensor Mount 1 Buddy Mount 1 BME Mount 1 BME Bracket 1 Switch Mount 1 <p>All parts for this project were printed on a Prusa Mk4s with PETG. We recommend the use of PETG.</p>"},{"location":"building/requirements/#required-software","title":"Required Software","text":"<p>The following software is required for the development/production of the Weather Station. Software under Development is simply for development while the software under the other sections is required for running the software suites.</p>"},{"location":"building/requirements/#development","title":"Development","text":"<ul> <li>VirtualBox - Virtual machine software</li> <li>git - Version control</li> <li>GitHub - Hosting platform for git-based projects</li> <li>OnShape - Online CAD platform</li> <li>KiCad - EDA software used to design PCBs</li> </ul> <p>Minimum Requirements</p> <p>Both the Broker and the API / Website were tested on hosts using the Ubuntu Server 24.04 distribution.</p>"},{"location":"building/requirements/#api-website","title":"API &amp; Website","text":"<p>The API is required to be ran on the same server as the Redis database. It is also recommended to host the website on the same server. The current implementation of Weather Station uses a server through Linode, specifically the Nanode plan.</p> <p>The API requirements are:</p> Param Recommended OS Ubuntu 24.04 Server (Or other Debian-based systems) Memory 2GB CPU Anything, really <p>Production Deployment</p> <p>It is STRONGLY recommended to use both a firewall and http server to deploy the API and website. We recommend the ufw firewall and nginx web server.</p> <p>CPU Requirements</p> <p>Almost any CPU will do for running the Website. Absolute minimum requirements have not been measured.</p>"},{"location":"building/requirements/#broker","title":"Broker","text":"<p>The broker has to be on-site and within range of the Weather Station's LoRa radio. It is recommended to run this on a Raspberry Pi 3B+ because that is what was tested and deployed in the initial design. The broker must be passed the device file which the RYLR896 radio UART is attached to.</p> Param Recommended OS Ubuntu 24.04 Server (Tested) Memory 1GB <p>CPU Requirements</p> <p>Almost any CPU will do for running the Broker. Absolute minimum requirements have not been measured.</p>"},{"location":"building/requirements/#firmware","title":"Firmware","text":"<p>To flash the firmware, it is recommended to build the firmware from source using the PlatformIO extension with VsCode and flash.</p> <p>There is also a good chance the CP2102 USB-to-UART chip drivers will be needed to recognize the ESP32 and program it.</p>"},{"location":"building/software-build/","title":"Building Software","text":"<p>This tutorial describes how to build the software suite for the Weather Station. Make sure the target system(s) have the required software as described in the previous section.</p>"},{"location":"building/software-build/#clone-the-repository","title":"Clone the Repository","text":"<p>Before building any software, you must have the most recent stable release of the Weather Station software suite located at our GitHub Repository. All target devices must have the software needed to build the various services.</p>"},{"location":"building/software-build/#broker","title":"Broker","text":"<p>The Broker is the service that relays information between the deployed Weather Station and the deployed server that holds the weather data. The broker is written with C++ using the libcurl library. Below is a simple block diagram of the broker's job:</p> <pre><code>graph LR\n    subgraph On-Site\n    ws[Weather Station] --&gt;|LoRa| b[Broker]\n    end\n    subgraph Cloud\n    b --&gt;|API Call| c[Internet]\n    c --&gt; s[Weather Station Server]\n    end</code></pre> <p>Operating System</p> <p>The following instructions are assuming you are running a debian-based operating system.</p>"},{"location":"building/software-build/#prerequisites","title":"Prerequisites","text":"<p>Install the following packages to build the broker:</p> <pre><code>sudo apt install cmake libcurl4-openssl-dev\n</code></pre> <p>This installs:</p> <ul> <li><code>cmake</code> For building the project</li> <li><code>libcurl4-openssl-dev</code> To get libcurl, which is used in the broker. If this package doesn't work, get your system's equal of the libcurl4 library using openssl.</li> </ul>"},{"location":"building/software-build/#building-the-broker","title":"Building the Broker","text":"<p>Change directory into the <code>/broker/broker</code> directory.</p> <p>Run the following command:</p> <pre><code>bash ./build.sh\n</code></pre> <p>This will build both the <code>bradley-cast-broker</code> and <code>bradley-cast-broker-test</code> executables.</p>"},{"location":"building/software-build/#running-the-broker","title":"Running the Broker","text":"<p>Running the broker requires the serial device file attached to the RYLR896 radio, the API endpoint of the server, and the API key file that is attached to the JSON request header.</p> <p>The following \"help\" will be outputted when the executable is ran: <pre><code>INVALID INPUT. SEE USAGE:\n\n\nBRADLEY CAST BROKER - ACCESS POINT OF WEATHER STATIONS TO SERVER DATABASE\n\nAUTHORS:\n  BRADLEY UNIVERSITY ECE398 WEATHER STATION PROJECT GROUP 2024\nUSAGE: \n  bradley-cast-broker [serial dev file] [API URL] [API key file]\n</code></pre></p> <p>You would run the broker like so:</p> <pre><code>bradley-cast-broker https://your.domain.com/api/envdata ./your-key-file.key\n</code></pre> <p>Broker Key Security</p> <p>Part of the broker's API calls is a POST request containing an API key. NEVER use unsecured HTTP.</p>"},{"location":"building/software-build/#broker-protocol-incoming-from-radio","title":"Broker Protocol (Incoming from Radio)","text":"<p>The ASCII protocol used to transfer data between the Weather Station and the Broker is like so:</p> <pre><code>T00.00|H00.00|P00.00|G00.00|R00.00|L00.00\n</code></pre> <p>An example payload could be:</p> <pre><code>T21.30|H82.34|P98.34|G210.34|R1023|L3569\n</code></pre>"},{"location":"building/software-build/#api-website","title":"API &amp; Website","text":"<p>The API handles retrieving and posting all data to the underlying redis database. All data must go through the API, including GET and POST requests. The API is built using Node.js and is written in the typescript language.</p> <p>Redis Database</p> <p>The redis database must be accessible at <code>localhost</code> on port <code>6379</code>. There is currently no security implemented which is why this requirement exists.</p>"},{"location":"building/software-build/#installing-redis","title":"Installing Redis","text":"<p>Run the following to install Redis, the database that stores all the weather data:</p> <pre><code>sudo apt-get install lsb-release curl gpg\ncurl -fsSL https://packages.redis.io/gpg | sudo gpg --dearmor -o /usr/share/keyrings/redis-archive-keyring.gpg\nsudo chmod 644 /usr/share/keyrings/redis-archive-keyring.gpg\necho \"deb [signed-by=/usr/share/keyrings/redis-archive-keyring.gpg] https://packages.redis.io/deb $(lsb_release -cs) main\" | sudo tee /etc/apt/sources.list.d/redis.list\nsudo apt-get update\nsudo apt-get install redis\n</code></pre> <p>Ensure the Redis database is running by checking the service's status using <code>systemctl</code>. You want to make sure it is running:</p> <pre><code>systemctl status redis-server.service\n</code></pre> <p>Make Redis database start when computer starts with: <pre><code>sudo systemctl enable redis-server\nsudo systemctl start redis-server\n</code></pre></p>"},{"location":"building/software-build/#installing-nodejs","title":"Installing Nodejs","text":"<p>You must install Node.js in order to run the API. Follow the instructions below to install it.</p> <p>You will need to run the following to get the tools needed:</p> <pre><code>sudo apt install curl\n</code></pre> <p>Then install Node.js:</p> <pre><code># Download and install nvm:\ncurl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.40.1/install.sh | bash\n# Download and install Node.js:\nnvm install 22 # You may have to restart your terminal before running this\n# Verify the Node.js version:\nnode -v # Should print \"v22.13.1\".\nnvm current # Should print \"v22.13.1\".\n# Verify npm version:\nnpm -v # Should print \"10.9.2\".\n</code></pre>"},{"location":"building/software-build/#building-the-api","title":"Building the API","text":"<p>You must have cloned the repository, as per the requirements. Change into the <code>/api</code> directory and run the following commands from there.</p> <p>Install the dependencies using npm (from inside <code>/api</code>):</p> <pre><code>npm install &amp;&amp; npm audit fix\n</code></pre> <p>Then build the API using:</p> <pre><code>npx tsc\n</code></pre> <p>Run the api using:</p> <pre><code>node index.js\n</code></pre>"},{"location":"building/software-build/#building-the-website","title":"Building the Website","text":"<p>Change into the <code>/website</code> directory of <code>VIP_Weather</code> and run the following to install necessary dependencies and fix audits:</p> <pre><code>npm install &amp;&amp; npm audit fix\n</code></pre> <p>Website Reaching API</p> <p>Currently, there is no nice way of changing the URL this website uses to fetch weather data. As of the writing of this documentation, you MUST change the URL present in the <code>getEnvironmentData()</code> function at the path: <code>/website/app/page.tsx</code>. Replace: <code>https://weather.jacobsimeone.net/api/envdata</code> with: <code>https://your.domain.here/api/envdata</code>.</p> <p>Then to build and run the website, use the following commands:</p> <pre><code>sudo npm run build &amp;&amp; npm run start\n</code></pre>"},{"location":"building/software-build/#securing-the-server","title":"Securing The Server","text":"<p>The following sections describe recommended security-related practices for any public deployment of this server. Currently, this includes adding a production web-server in front of our API and website (Nginx) as well as a firewall. For this tutorial, we will be using the <code>ufw</code> firewall, but you can use whatever one you would like.</p>"},{"location":"building/software-build/#nginx","title":"Nginx","text":"<p>Nginx is a web-server that sits \"in front of\" the API and website. Sort of like this:</p> <pre><code>graph LR\n    c[Client]\n    n[Nginx]\n    a[API]\n    w[Website]\n\n    c ----&gt;|HTTPS| n\n    subgraph Server\n    n --&gt; a\n    n --&gt; w\n    end</code></pre>"},{"location":"building/software-build/#installing-nginx","title":"Installing Nginx","text":"<p>Run the following to install and enable the Nginx software on your system: <pre><code>sudo apt install nginx\n</code></pre></p> <p>To verify this is working, you can go to: <code>https://localhost/</code> on the target system in a web browser, and you should see the Nginx welcome page (if you have a GUI available to you).</p> <p>As always, you can check the status of nginx with <code>systemctl</code>:</p> <pre><code>systemctl status nginx\n</code></pre> <p>The nginx service should be both running and enabled.</p>"},{"location":"building/software-build/#configuration","title":"Configuration","text":"<p>Nginx configuration is typically stored in the <code>/etc/nginx/</code> directory. It is recommended to remove the default configuration with:</p> <pre><code>sudo rm /etc/nginx/sites-enabled/default\n</code></pre> <p>Then create a new file <code>/etc/nginx/sites-enabled/weather-station</code> and copy/paste the following contents:</p> <pre><code>server {\n    server_name your.domain.here;\n\n    location / {\n        proxy_pass http://localhost:5050/;\n    }\n\n    location /api {\n        proxy_pass http://localhost:27500/api;\n    }\n}\n</code></pre> <p>Then re-start the Nginx server for the changes to take effect:</p> <pre><code>sudo systemctl restart nginx\n</code></pre>"},{"location":"building/software-build/#securing-with-https","title":"Securing with HTTPS","text":"<p>TODO: LetsEncrypt</p>"},{"location":"building/software-build/#firewall","title":"Firewall","text":"<p>It is highly recommended to run a firewall on the server running the API and web server. For both the API and the web server, we must allow HTTP requests. For <code>ufw</code> firewall, run:</p> <pre><code>sudo ufw allow \"Nginx Full\"\n</code></pre> <p>Note the above requires Nginx to be installed to work. This opens port 80 and port 443</p> <p>If <code>ufw</code> is not already enabled, you can enable it by running: <pre><code>sudo ufw enable\n</code></pre></p> <p>SSH/Remote Desktop Connections</p> <p>Before enabling the firewall, make sure that you have access to your server through a physical connection (like mouse and keyboard or serial port) or you allow ssh traffic with ufw like so: <code>sudo ufw allow 22/tcp</code></p>"},{"location":"building/software-build/#firmware","title":"Firmware","text":"<p>Ensure that an ESP32-DevkitM1 board is attached to your computer through a USB cable before attempting to flash firmware. </p> <p>CP2102 Device Drivers</p> <p>The ESP32-DevkitM1 board uses a CP2102 USB-to-UART chip to communicate between the connected USB device and the microcontroller. It is very important on Windows that you have installed the CP2102 device drivers otherwise the ESP32 cannot communicate with the attached computer. Other operating systems have not been tested.</p> <p>Navigate to the <code>/firmware</code> directory in the repository, open it in VsCode, and ensure the PlatformIO extension is installed. When the project opens, make sure that PlatformIO is started and recognizes the project, otherwise the following commands will not work.</p> <p>With the project open, run the <code>PlatformIO: Build</code> to build the firmware project, and then the <code>PlatformIO: Upload</code> to upload the firmware to the attached device. The attached ESP32 should now be running the Weather Station firmware. (Access command palate using <code>ctrl+shift+p</code>) You can also use the icons at the bottom of the screen for building &amp; uploading with PlatformIO.</p> <p>Verify Firmware</p> <p>To ensure that firmware is working, put the development board back in the Weather Station and ensure the status LED is operating.</p>"},{"location":"developers/broker/","title":"Introduction","text":"<p>The broker is the software used to forward data from the Weather Station. The broker handles the data between the packets received on the attached radio, and the API running in the cloud. The broker is written in C++, and is designed to run on POSIX systems that also have the necessary dependencies installed as listed in the software build documentation.</p> <p>A logical diagram of the broker is below:</p> <pre><code>flowchart LR\n\nsubgraph \"Weather Station\"\nwsH[Weather Station] --&gt;|UART| wsR[RYLR896 Radio]\nend\n\nsubgraph \"Embedded Linux Computer\"\nbR[RYLR896 Radio] --&gt;|UART| broker[Broker]\nend\n\nwsR --&gt;|LoRa| bR\n\nbroker --&gt;|HTTP POST| API</code></pre>"},{"location":"developers/broker/#running-the-broker","title":"Running the Broker","text":"<p>The broker application comes with a file: <code>start-broker.sh</code> that gives an example for starting the broker. It is up to the user to find the device file that corresponds to the connected RYLR896 radio. There are lots of tutorials for this on the internet, but some useful commands are:</p> <ul> <li><code>ls -l /dev/tty*</code> -&gt; List attached tty device files. Some common names are <code>ttySX</code>, <code>ttyACMX</code>, <code>ttyUSBX</code>, depending on how the port is connected.</li> <li><code>sudo picocom -b &lt;baud rate&gt; &lt;device file&gt;</code> -&gt; Open a terminal to read data from serial port</li> </ul> <p>start-broker.sh example:</p> <p><code>./build/bradley-cast-broker /dev/ttyS0 https://weather.jacobsimeone.net/api/envdata ./api.key</code></p>"},{"location":"developers/firmware/","title":"Overview","text":"<p>The firmware is written in C++, using the PlatformIO IDE within VsCode, and using the Arduino framework. The firmware currently targets the ESP32 microcontroller.</p> <p>The firmware, which runs on the ESP32 controller, is responsible for reading data from all of the attached sensors, and then sending that data through the on-board radio and out to the API.</p>"},{"location":"developers/protocol/","title":"Protocol","text":"<p>The protocol currently used to transfer data between the LoRa RYLR896 radio on the Weather Station to an identical radio on the broker uses ASCII to encode plain-text data.</p>"},{"location":"developers/protocol/#protocol","title":"Protocol","text":"<p>Note that the protocol used to communicate over the radio is NOT the binary protocol described in the wiki, but is a simple ASCII string. </p> <p>String: <code>T00.00|H00.00|P00.00|G00.00|R00.00|L00.00</code></p> <p>There is more data transmitted over the LoRa radio, but the string above is what the payload looks like.</p> <p>Future Protocol</p> <p>In the future, the binary protocol defined elsewhere in this documentation will be used for transferring environmental data.</p>"},{"location":"developers/protocol/#future","title":"Future","text":"<p>In the future, another protocol that uses binary support would be better for throughput as the same data can be encoded in less bits sent.</p>"},{"location":"developers/website/","title":"Overview","text":"<p>The website is written using the Next.js web development framework, primarily using the typescript language. Primarily, the website is designed to be a showcase of what a client can do with the data available at the API. Currently, the Weather Station website is available at:</p> <p>weather.jacobsimeone.net</p>"},{"location":"developers/website/#maintenance-mode","title":"Maintenance Mode","text":"<p>The website has a \"maintenance mode\" feature that is enabled by the presence of a <code>under-maintenance.txt</code> file in the root website directory (<code>/website</code> in the repository). </p> <p>When a request to the server is made, a check is performed to determine if this file exists. If the file exists, a maintenance mode page is displayed. </p> <p>A maintenance log feature is also available through the presence of a file called <code>maintenance.log</code>. The contents of this file will be parsed line-by-line and displayed as a maintenance log. It is recommended to use this format:</p> <pre><code>[2025-01-24T14:00:00-06:00] Log entry 3\n[2024-12-02T10:30:00-06:00] Log entry 2\n[2024-11-21T14:00:00-06:00] Log entry 1\n</code></pre>"},{"location":"posts/battery-box/","title":"Battery Box Temp Measurement","text":""},{"location":"posts/battery-box/#measuring-internal-battery-box-temperature","title":"Measuring Internal Battery Box Temperature","text":"<p>In order for the weather station to be deployed outdoors in an environment where a USB port may not be available, we are designing a battery box that we will use to power the station. It sports a 10Ah Lithium Ion battery with a on/off switch, cable gland, and all of that packed in an Amazon waterproof case. </p> <p>It looks a little like this: </p> <p></p> <p>Battery box from setup for thermal testing, 2024-10-19</p> <p></p> <p>Battery box under the new production weather station, on the first build day of the battery box, 2024-10-17</p> <p>The schematics for the box (although crude) look like so:</p> <p></p> <p>Battery box schematics as of 2024-10-20*</p>"},{"location":"posts/battery-box/#temperature-consideration","title":"Temperature Consideration","text":"<p>We are using a switching regulator to step the nominal 12V down to a nominal 5V. Because this box was going to be set up relatively long term outdoors, we wanted a good idea of the thermals inside of the box. In order to accomplish this, we measured the internal temperature of the box while under an expected load. </p> <p>To measure the temperature, we used a thermocouple and some logging software to monitor the temperature over time. You can see the thermocouple location in the first image of this article. I set up the test with the box closed and let it run until the temperature seemed to level off. </p> <p>This was what my (very messy) setup looked like. Note I'm using a personal project with an LCD display and microcontroller to simulate the load: </p> <p></p> <p>Setup of thermal measurement test</p>"},{"location":"posts/battery-box/#results","title":"Results","text":"<p>After some time, it was found that the temperature leveled off at about 97 degrees F, which was a little more than 20 degrees over ambient. All things considered, this was a pretty good result and we are going to move forward with deploying this system. </p> <p></p> <p>Results of test performed on 2024-10-19</p> <p>Last edited by Jacob Simeone - 2024-10-20</p>"},{"location":"posts/bradley-cast/","title":"Bradley-Cast Protocol (Proposed)","text":"<p>This is the proposed \"Bradley-Cast\" binary protocol that the weather station will (hopefully) eventually use. Currently, the Weather Station implements a simpler ASCII-based protocol which is documented elsewhere.</p> <p>Protocol Not Part of Weather Station Right Now</p> <p>This is a proposed protocol, and is currently UNIMPLEMENTED. See the README for details on ASCII encoded protocol currently implemented. Note the radio being used currently does NOT support raw, binary data transmission. </p>"},{"location":"posts/bradley-cast/#development-overview","title":"Development Overview","text":"<p>The protocol defining messages that the microcontroller will send over the LoRa 915Mhz radio link. </p> <p>This will focus on transmitting sensor data to the Raspberry Pi when there are multiple microcontrollers with different sensors.</p> <p></p>"},{"location":"posts/bradley-cast/#data","title":"DATA","text":"<p>We have the following integer data to transmit:</p> Name Bits Unit Scale Signed? Temperature 16 deg C x100 yes Humidity 16 percent x100 no Pressure 16 kPa x100 no <p>Notice the scale parameter set in the table. This is to guarantee fixed point data only on the link between the microcontroller and the Pi.</p> <p>Example: The temperature sensor reads 25.62\u00b0C, which is 32 bit. We don't want to transmit the decimal point, as that increases the bit count. Instead, we can do this: In the microcontroller, multiply the value by 100. 25.62 x 100 = 2562. Then we transmit this to the Raspberry Pi. The Raspberry Pi picks up 2562, and we tell the Pi to divide the value by 100, turning it back into 25.62\u00b0C. This is where the scale comes from. </p> <p>We also need to transmit the following:</p> <ul> <li>Is it raining?</li> <li>Is it cloudy? Sunny? Gloomy?</li> </ul> <p>Is Raining? shall just be one bit, on or off</p> <p>Sunny/Cloudy/Gloomy we can use 2 bits to represent each state as an integer:</p> <ul> <li><code>0b00</code> (0 decimal): Sunny</li> <li><code>0b01</code> (1 decimal): Cloudy</li> <li><code>0b10</code> (2 decimal): Gloomy</li> </ul> <p>We can export Raining and Sunny/Cloudy/Gloomy together as 3 bits and add 5 bits of padding to export in 8 bit which results in total data being:</p> Name Bits Unit Scale Signed? Temperature 16 deg C x100 YES Humidity 16 percent x100 NO Pressure 16 kPa x100 NO RSCG 8 mixed N/A NO <p>Where <code>RSCG</code> is:</p> RESERVED Cloudy/Sunny/Gloomy IS RAINING? 0b111 0b110 0b101 0b100 0b011 0b010 0b001 0b000 <p>From here on out, Rain, Sunny/Cloudy/Gloomy will be referred to as: <code>RSCG</code>.</p>"},{"location":"posts/bradley-cast/#unique-identifiers","title":"Unique Identifiers","text":"<p>However, we are assuming that the Raspberry Pi is receiving data from different microcontrollers.  Thus, we need a way to identify the microcontrollers so that the Pi can differentiate between them. We do this with an ID. We add a unique ID in front of the microcontroller and the environmental message. The transmission would look like this:</p> <p><code>[ID][ENV MSG]</code> instead of just <code>[ENV MSG]</code> to the Raspberry Pi. Now we can have unique IDs for each microcontroller to send data to the Pi.</p> <p>ID Examples</p> <p>Temp ID = 0 (integer) 00 (binary)</p> <p>Humid ID = 1 (integer) 01 (binary)</p> <p>Pres ID = 2 (integer) 10 (binary)</p> <p>RSCG ID = 3 (integer) 11 (binary)</p> <p></p>"},{"location":"posts/bradley-cast/#message-specification","title":"Message Specification","text":"<p>All messages shall be sent in the following format, and shall be in network byte order:</p> STATION ID (64-bit) MSG ID (16-bit) MSG (Variable-length)"},{"location":"posts/bradley-cast/#station-id-specification","title":"Station ID Specification:","text":"<p>A STATION ID will be a unique identifier assigned to each unique device communicating with the broker. The STATION ID will have the following requirements:</p> <ul> <li>exactly 64 bits long</li> <li>MSB format on message transmission</li> </ul>"},{"location":"posts/bradley-cast/#message-id-specification","title":"Message ID Specification:","text":"<p>Each message shall have a message ID attached to it, identifying the type of data contained in the message. The message ID shall:</p> <ul> <li>Be exactly 2 bytes</li> <li>Be populated after the UUID of the device sends the message</li> </ul>"},{"location":"posts/bradley-cast/#messages","title":"Messages","text":"<p>Technical descriptions of each message capable of being sent over the Bradley-Cast protocol. </p>"},{"location":"posts/bradley-cast/#env-data-message","title":"ENV Data Message","text":"ID: 0x0010 <p>FORMAT:</p> Temperature (16 bits) Humidity (16 bits) Pressure (16 bits) RSCG (8 bits) <p>WHERE:</p> NAME UNITS SCALE SIGNED? LEN (BYTES) Temperature Degrees C $10^2$ YES 2 Humidity Percent $10^2$ NO 2 Pressure kPa $10^2$ NO 2 RSCG ENUM / BOOL 1 NO 1 <p>RSCG - DETAILS</p> RESERVED Cloudy/Sunny/Gloomy IS RAINING? 0b1111 ... 0b011 0b010 0b001 0b000 <p>VALID VALUES OF CLOUDY/SUNNY/GLOOMY:</p> <ul> <li><code>Sunny</code> = 0</li> <li><code>Cloudy</code> = 1</li> <li><code>Gloomy</code> = 2</li> </ul> <p>Example Payload (in hex): </p> 01 90 10 16 27 FD 03 <p><code>0x03 = 0b00000011</code> -&gt; Is raining, and is also cloudy</p> <p>With: - Temperature = 4 degrees C - Pressure = 102.37 kPa - Humidity = 41.18 % - IS RAINING - CLOUDY</p>"},{"location":"posts/ecclipse-data/","title":"Eclipse Data","text":"<p>The Bradley University Weather station team managed to catch some data of the April 2024 solar eclipse with a prototype version of the Weather Station. The following data is shown below. </p> <p></p>"},{"location":"posts/esp32-rf-range/","title":"Range Issues","text":"<p>Since the first prototype release of the Weather Station on March 1st, 2024, its been noted by members of the team that the range is near pitiful. A test was performed on 2024-03-04, which found that walking around the fourth floor of the BECC, the WiFi signal from the ESP32 was recognizable all throughout the fourth floor, showing a low of <code>~89db</code> at some points. </p> <p>In this wiki, using some RF calculations, we will answer why this may be the case. </p>"},{"location":"posts/esp32-rf-range/#range-in-math","title":"Range in Math","text":"<p>There are ways to calculate this kind of thing, making lots of assumptions. You can find more information here, written by people far smarter than myself. </p> <p>The long story short is this: How far can the signal, transmitted from the ESP32, reach?</p> <p>To get the distance, we need to know a few things:</p> <ul> <li><code>Frequency (MHz)</code> -&gt; What frequency our WiFi network is on.</li> <li><code>Transmit Power (db)</code> -&gt; The amount of power coming out of the antenna on the Weather Station.</li> <li><code>Receive Sensitivity (dbm)</code> -&gt; The minimal amount of power needed to receive from a transmitter.</li> <li><code>Antenna Gain (db)</code> -&gt; The amount of power an antenna adds through directionality or how much power an antenna can focus.</li> <li><code>Fade Margin (db)</code> -&gt; A margin used for the power we would like to receive at while being above the minimum receiver sensitivity.</li> <li><code>Other Losses (db)</code> -&gt; Walls, reflections, etc. </li> </ul> <p>In our case, we're working with the following parameters:</p> <ul> <li><code>Frequency = 2400 MHz</code> -&gt; Another assumption. this could actually change a bit depending on the channel, but the ESP32 seems to dwell on channels that are close to this value based on very limited testing.</li> <li><code>Transmit power = 20db</code> -&gt; Configured in code and is the maximum output power of the ESP32.</li> <li><code>Receive Sensitivity = -85dbm</code> -&gt;  Typical sensitivity of a common 802.11g module, according to Google. </li> <li><code>Antenna Gain = 1db</code> -&gt; A typical value for a PCB antenna.</li> <li><code>Fade Margin = 15db</code> -&gt; A number that's kind of wishy-washy, but on the high end of what the source  linked above recommended. This is because of all the extra \"stuff\" in the RF space here at Bradley University as well as the varying number of walls the signal will have to go through. </li> </ul> <p>The Next Thing we need to know, is the Free Space Path Loss formula. Specifically, the form of the equation which uses km for distance and GHz for frequency:</p> \\[ \\text{FSPL} = 20\\log_{10}{d_{km}} + 20\\log_{10}{f_{GHz}} - 92.45 \\] <p>Where:</p> <ul> <li>\\(f\\) is frequency, in GHz</li> <li>\\(d\\) is distance, in km</li> </ul> <p>Next, we need to know our Maximum path loss for the next formula. The maximum path loss is the difference between your effective transmit power and your effective receive power.</p> <p>In other words, how much power can I lose before the signal strength is too low?</p> <p>Maximum path loss is roughly this (with some assumptions):</p> \\[ \\text{Max path loss} = \\text{Tx power} - \\text{Rx sensitivity} + \\text{Tx gain} - \\text{Fade margin} - \\text{other losses} \\] <p>Re-arranging this formula for distance (\\(d\\)) gives us the following:</p> <p>source (Please note that units change from frequency was in GHz and is now in MHz)</p> \\[ d_{km} = 10^{(\\text{max path loss} - 32.44 - 20\\log_{10}{f_{MHz})/20}} \\]"},{"location":"posts/esp32-rf-range/#other-losses","title":"Other Losses","text":"<p>We need to account for other RF losses, which in our case, are mostly walls. Accounting for:</p> <ul> <li><code>4 walls average = 7db * 4 = 24db</code> -&gt; Very arbitrarily assuming 10.5\" brick walls, with the 7db loss coming from this source. (Mostly arbitrary numbers, these could be improved)</li> </ul>"},{"location":"posts/esp32-rf-range/#range-solution","title":"Range Solution","text":"<p>The very, very, very crude estimated range solution is this:</p> \\[ \\text{Max Path Loss} = 20 - (-85) + 1 - 15 - 24 = 67\\text{db} \\] \\[ d_km = 10^{ ( 67 - 32.44 - 20\\log_{10}{2400} ) / 20} = 0.0222735\\text{km} \\approx 22\\text{m} \\] <p>Our estimate is approximately: <code>22 meters</code> or <code>roughly 72 feet</code>. This is a fair estimate of the range that observed while testing. </p> <p>Note: This math makes a ton of assumptions and stuff like this isn't easy to calculate, so this number could be quite far off</p>"},{"location":"posts/esp32-rf-range/#other-factors-that-effect-range","title":"Other Factors That Effect Range","text":"<p>Antenna polarization -&gt; Our antenna probably isn't a isotropic radiator which means that the signal strength is going to change based on the side of the antenna you're facing. </p> <p></p> <p>source</p> <p>More walls -&gt; The wall loss estimation accounts poorly for obstacles. This number may be too high or too low and could be causing an inaccurate estimation.</p> <p></p> <p>source</p> <p>Elevation -&gt; Since most of the power of the antenna is radiated horizontally, lowering your elevation relative to the antenna is going to significantly decrease your signal strength. (Walk a couple steps down the stairs and see how fast you lose signal)</p> <p>Srouces:</p> <ul> <li>electronicdesign.com</li> <li>securitytody.com</li> </ul>"},{"location":"posts/over-campus-test/","title":"Sensor Issues","text":"<p>During the development of the weather station, it was found that the temperature sensor mounted internally was causing the station to report very high temperatures compared to the \"real\" ambient temperature reported by the NWS (20-40 degrees higher). The leading theory for this issue was that the BECC building was cooking the sensor and artificially raising the temperature of the sensor.</p> <p>The solution to this problem was to mount the sensor outside the box in a small, well-ventilated enclosure, which was implemented. </p> <p></p> <p>New 3d-printed case manufactured out of PETG enclosing the weather station's temperature sensor</p>"},{"location":"posts/over-campus-test/#the-temperature-was-wrong-again","title":"The Temperature was Wrong... again?","text":"<p>After mounting the new sensor, it was found that the temperature was still ten degrees higher than what the National Weather Service and other sources were reporting. Again, the theory was still that the BECC was cooking the sensor. To verify this, a thermocouple measurement board was used to detect the ambient air temperature around the building and... it was the same as what the sensor was reporting. </p> <p></p> <p>Measuring the ambient air temperature with a thermocouple using a Playing with Fusion FDQ-30001 board</p> <p>It was clear that the issue was simply the weather station was too close to the BECC and that the glass and concrete were radiating too much heat to get an accurate measurement for ambient air temperature.</p>"},{"location":"posts/over-campus-test/#what-was-done-wrong","title":"What was Done Wrong","text":"<p>It all started when we mounted the Weather Station: the location was not conducive to accurately measuring ambient temperature. The large glass building was reflecting the sunlight towards the Weather Station's location, heating it to well above ambient temperature. </p> <p>After some research, we found an article about measuring ambient air temperature, and one of the major issues listed was: \"Don't put ambient air measurement equipment near large buildings or pavement.\" With the current Weather Station location in front of the BECC, we were doing exactly that.</p>"},{"location":"posts/over-campus-test/#the-new-test","title":"The New Test","text":"<p>These issues arose a question: is campus as a whole truly that much warmer, or was this issue just in front of the BECC? To find the answer to this, the team went around campus measuring a couple points and comparing that data to the National Weather Service reported data. Unfortunately, the day chosen to perform these measurements was bitterly cold, and the team only got about four locations measured. </p> <p>Test was conducted on 2025-02-13, at around 1:00pm</p> <p>This data can be visualized with the GPS data with the Test Html.</p>"},{"location":"posts/over-campus-test/#our-test-data","title":"Our Test Data","text":"Time Temp (C) Pressure (kPa) 13:19 10.7 (C) 100.9 kPa 13:22 7.8 (C) 100.9 kPa 13:26 5.5 (C) 100.9 kPa 13:31 2 (C) 101.0 kPa"},{"location":"posts/over-campus-test/#nws-data","title":"NWS Data","text":"Time Temp (C) Pressure (kPa) 13:54 -8.0 (C) -- 12:54 -8.8 (C) -- <p>Last Updated 2025-02-13-20:45 by Jacob S</p>"},{"location":"posts/pole/","title":"Pole","text":"<p>#Omg it's a pole</p>"},{"location":"posts/rtd-board/","title":"Custom RTD Board","text":"<p>A significant priority with the BU Weather Station is that it needs to measure temperature accuratley. For most users, the temperature alone is the most important piece of information, thus reporting and logging said temperature correctly is paramount.</p> <p>During development, we used both a BME680 and BME280 environment sensor from Bosch-Sensortec. Both of these sensors have an accuracy of +- 0.5-1 degree Celsius. </p> <p>To solve these issues, and as a learning expereince, the BU Weather Station team decided to make a custom printed circuit board (PCB) to carry a sensor capable of turning an RTD (Resistive Temperature Device) signal into a high-accuracy temperature. This board is shown below.</p> <p></p> <p>This board includes:</p> <ul> <li>An Analog Devices MAX31865 RTD to digital converter</li> <li>A NCP1117 3.3V fixed output voltage regulator</li> <li>A Texas Instruments TXB0108PWR Level Translator</li> </ul> <p>The RTD to digital converter converts a RTD signal to a temperature that the microcontroller can read through SPI. This board can be used with 2, 3, or 4 wire RTDs by jumping the corresponding pads. The voltage regulator and level translator allow the board to be used with either 3v3 or 5v supplies and logic. </p>"},{"location":"posts/rtd-board/#manufacturing","title":"Manufacturing","text":"<p>The BU Weather Station team needed to assemble the board themselves due to the board and components arriving seperately. Most similar boards are either hand-soldered or reflow-soldered in an oven. The BU Weather Station team opted to manufacture our board with reflow-soldering. This was done using an off-the-shelf toaster oven with a custom software/hardware solution as well as a stencil from OshStencils.</p> <p></p> <p>Custom reflow-oven</p>"}]}